<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>劇場公演 出演回数ツール</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
        Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f9f9f9;
      color: #222;
      max-width: 390px;
      margin-left: auto;
      margin-right: auto;
    }

    header h1 {
      font-size: 1.5rem;
      text-align: center;
      margin-bottom: 1.5rem;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
      font-size: 1rem;
      color: #333;
    }

    select {
      display: block;
      width: 100%;
      font-size: 1rem;
      padding: 8px 10px;
      margin-bottom: 20px;
      border-radius: 6px;
      border: 1px solid #ccc;
      box-sizing: border-box;
      background-color: white;
    }

    #output {
      background: #fff;
      padding: 10px 14px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      white-space: pre-wrap;
      line-height: 1.5;
    }

    .highlight {
      font-weight: bold;
      color: #1976d2;
      font-size: 1.2rem;
      margin-bottom: 0.75rem;
    }

    h3 {
      margin-top: 1.5rem;
      margin-bottom: 0.4rem;
      font-weight: bold;
      font-size: 1.1rem;
      color: #333;
    }

    ol, ul {
      margin-left: 1.2rem;
      margin-bottom: 1rem;
      padding-left: 1rem;
    }

    li {
      margin-bottom: 0.25rem;
    }

    details summary {
      font-weight: bold;
      cursor: pointer;
      padding: 0.3rem 0;
    }

    details[open] summary {
      color: #1976d2;
    }
  </style>
</head>
<body>
  <header><h1>劇場公演 出演回数ツール</h1></header>

  <!-- グループ選択 -->
  <label for="group-select">グループを選択：</label>
  <select id="group-select">
    <option value="">-- グループを選択 --</option>
  </select>

  <!-- メンバー選択 -->
  <label for="member-select">メンバーを選択：</label>
  <select id="member-select" disabled>
    <option value="">-- メンバーを選択 --</option>
  </select>

  <!-- 出力表示エリア -->
  <div id="output"></div>

  <script>
    const GROUPS_URL = './src/data/groups.json';
    const PERFORMANCE_URL = './src/data/performance.json';

    let groups = {};
    let performances = [];

    const groupSelect = document.getElementById('group-select');
    const memberSelect = document.getElementById('member-select');
    const output = document.getElementById('output');

    async function fetchGroups() {
      const res = await fetch(GROUPS_URL);
      if (!res.ok) throw new Error('groups.jsonの取得に失敗しました');
      groups = await res.json();
    }

    async function fetchPerformances() {
      const res = await fetch(PERFORMANCE_URL);
      if (!res.ok) throw new Error('performance.jsonの取得に失敗しました');
      performances = await res.json();
    }

    function setupGroupOptions() {
      Object.keys(groups).forEach(group => {
        const opt = document.createElement('option');
        opt.value = group;
        opt.textContent = group;
        groupSelect.appendChild(opt);
      });
    }

    function onGroupChange() {
      const selectedGroup = groupSelect.value;
      memberSelect.innerHTML = '<option value="">-- メンバーを選択 --</option>';
      memberSelect.disabled = !selectedGroup;
      output.innerHTML = '';
      if (!selectedGroup) return;

      groups[selectedGroup].forEach(member => {
        const opt = document.createElement('option');
        opt.value = member;
        opt.textContent = member;
        memberSelect.appendChild(opt);
      });
    }

    function sortRankingWithTies(arr) {
      // 同点は同順位にして昇順に並べる関数
      // arr: [{name, count}] の配列
      arr.sort((a, b) => b.count - a.count || a.name.localeCompare(b.name));
      let rank = 1;
      let lastCount = null;
      let lastRank = 0;
      arr.forEach((item, i) => {
        if (item.count !== lastCount) {
          lastRank = i + 1;
          lastCount = item.count;
        }
        item.rank = lastRank;
      });
      return arr;
    }

    function onMemberChange() {
      const member = memberSelect.value;
      output.innerHTML = '';
      if (!member) return;

      const today = new Date();

      // 過去公演と未来公演に分ける
      const pastPerformances = performances.filter(p => new Date(p.date) <= today);
      const futurePerformances = performances.filter(p => new Date(p.date) > today);

      // 対象メンバーの過去出演公演
      const memberPast = pastPerformances.filter(p => p.members.includes(member));
      const totalCount = memberPast.length;

      // 出演履歴は日付昇順（古い→新しい）で番号付け＝最新が最後の番号
      const history = memberPast
        .slice()
        .sort((a, b) => a.date.localeCompare(b.date))
        .map((p, i) => `${i + 1}回目 ${p.date} ${p.stage}${p.time ? '（' + p.time + '）' + '' : ''}`);

      // 節目達成日（100回ごと）
      const milestoneNum = Math.floor(totalCount / 100) * 100;
      let milestoneDate = '';
      if (milestoneNum > 0) {
        const milestonePerf = pastPerformances.find(p => p.members.includes(member) && 
          memberPast.filter(mp => mp.date <= p.date).length === milestoneNum);
        if (milestonePerf) {
          milestoneDate = `${milestoneNum}回目は ${milestonePerf.date} の「${milestonePerf.stage}」${milestonePerf.time ? '（' + milestonePerf.time + '）' : ''} 公演`;
        }
      }

      // 節目予測（総出演回数の下2桁が90～99のときのみ表示）
      let milestonePrediction = '';
      const countMod100 = totalCount % 100;
      if (countMod100 >= 90 && totalCount > 0) {
        const remaining = 100 - countMod100;
        const futureMilestonePerf = futurePerformances.filter(p => p.members.includes(member))[remaining - 1];
        if (futureMilestonePerf) {
          milestonePrediction = `（${totalCount + remaining}回目は ${futureMilestonePerf.date} の「${futureMilestonePerf.stage}」${futureMilestonePerf.time ? '（' + futureMilestonePerf.time + '）' : ''} 公演の予定）`;
        } else {
          milestonePrediction = `あと${remaining}回で${totalCount + remaining}回の節目達成！`;
        }
      }

      // 演目別出演回数（出演履歴の公演に限定）
      const stageCounts = {};
      memberPast.forEach(p => {
        if (!stageCounts[p.stage]) stageCounts[p.stage] = 0;
        stageCounts[p.stage]++;
      });

      // 演目別出演回数ランキング（出演履歴に出演した全メンバーのカウント）
      const stageRankingRaw = {};
      memberPast.forEach(p => {
        if (!stageRankingRaw[p.stage]) stageRankingRaw[p.stage] = {};
        p.members.forEach(m => {
          stageRankingRaw[p.stage][m] = (stageRankingRaw[p.stage][m] || 0) + 1;
        });
      });

      // group.jsonの順で演目別ランキング表示の順番を決めるため、演目の順序取得
      const stageOrder = Object.keys(stageCounts);

      // 各演目のランキングを整形
      const stageRanking = {};
      stageOrder.forEach(stage => {
        const arr = Object.entries(stageRankingRaw[stage]).map(([m, c]) => ({name: m, count: c}));
        stageRanking[stage] = sortRankingWithTies(arr);
      });

      // 年別出演回数ランキング（出演履歴に限定）
      const yearRankingRaw = {};
      memberPast.forEach(p => {
        const year = p.date.slice(0,4);
        if (!yearRankingRaw[year]) yearRankingRaw[year] = {};
        p.members.forEach(m => {
          yearRankingRaw[year][m] = (yearRankingRaw[year][m] || 0) + 1;
        });
      });

      const yearOrder = Object.keys(yearRankingRaw).sort();
      const yearRanking = {};
      yearOrder.forEach(year => {
        const arr = Object.entries(yearRankingRaw[year]).map(([m, c]) => ({name: m, count: c}));
        yearRanking[year] = sortRankingWithTies(arr);
      });

      // 共演回数ランキング（出演履歴のみ）
      const coCounts = {};
      memberPast.forEach(p => {
        p.members.forEach(m => {
          if (m === member) return;
          coCounts[m] = (coCounts[m] || 0) + 1;
        });
      });
      const coRanking = sortRankingWithTies(Object.entries(coCounts).map(([m, c]) => ({name: m, count: c})));

      // 出力HTML作成
      let html = `
        <div class="highlight">総出演回数: ${totalCount}回</div>
        ${milestoneDate ? `<div>節目達成日: ${milestoneDate}</div>` : ''}
        ${milestonePrediction ? `<div>節目予測: ${milestonePrediction}</div>` : ''}
        <div>
          <h3>出演履歴</h3>
          <ol>${history.map(h => `<li>${h}</li>`).join('')}</ol>
        </div>
        <div>
          <h3>演目別出演回数</h3>
          <ul>${Object.entries(stageCounts).map(([stage, count]) => `<li>${stage}：${count}回</li>`).join('')}</ul>
        </div>
        <div>
          <h3>演目別出演回数ランキング</h3>
          ${stageOrder.map(stage => `
            <details>
              <summary>${stage}</summary>
              <ol>
                ${stageRanking[stage].map(item => `<li>${item.rank}. ${item.name} (${item.count}回)</li>`).join('')}
              </ol>
            </details>
          `).join('')}
        </div>
        <div>
          <h3>年別出演回数ランキング</h3>
          ${yearOrder.map(year => `
            <details>
              <summary>${year}年ランキング</summary>
              <ol>
                ${yearRanking[year].map(item => `<li>${item.rank}. ${item.name} (${item.count}回)</li>`).join('')}
              </ol>
            </details>
          `).join('')}
        </div>
        <div>
          <h3>共演回数ランキング</h3>
          <ol>
            ${coRanking.map(item => `<li>${item.rank}. ${item.name} (${item.count}回)</li>`).join('')}
          </ol>
        </div>
      `;

      output.innerHTML = html;
    }

    async function init() {
      try {
        await fetchGroups();
        await fetchPerformances();
        setupGroupOptions();
        groupSelect.addEventListener('change', onGroupChange);
        memberSelect.addEventListener('change', onMemberChange);
      } catch(e) {
        output.innerHTML = `<p style="color:red;">データの読み込みに失敗しました: ${e.message}</p>`;
        groupSelect.disabled = true;
        memberSelect.disabled = true;
      }
    }

    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>